<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game Demonstrator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1em;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .chess-section {
            flex: 2;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .move-display-section {
            flex: 1;
            padding: 30px;
            background: #ecf0f1;
            border-left: 3px solid #3498db;
            border-right: 3px solid #3498db;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
        }

        .current-move-display {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center;
            width: 100%;
            margin-bottom: 20px;
        }

        .move-number {
            font-size: 3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .move-text {
            font-size: 2.5em;
            color: #3498db;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
            min-height: 1.2em;
        }

        .move-description {
            font-size: 1.1em;
            color: #7f8c8d;
            font-style: italic;
            margin-bottom: 20px;
        }

        .position-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            margin-bottom: 20px;
        }

        .position-info h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: bold;
            color: #34495e;
        }

        .info-value {
            color: #2c3e50;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .control-panel {
            flex: 2;
            background: #f8f9fa;
            padding: 30px;
            overflow-y: auto;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            border: 3px solid #2c3e50;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin-bottom: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            position: relative;
            transition: all 0.3s ease;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.highlight {
            background-color: #ffeb3b !important;
            box-shadow: inset 0 0 10px rgba(255,193,7,0.8);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .game-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
        }

        .game-info h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row span:first-child {
            font-weight: bold;
            color: #34495e;
        }

        .info-row span:last-child {
            color: #2c3e50;
            font-family: 'Courier New', monospace;
            text-align: right;
            flex: 1;
            margin-left: 15px;
            font-weight: bold;
        }

        .moves-display {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .moves-display h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .move-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .move-item {
            padding: 6px 12px;
            background: #ecf0f1;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .move-item:hover {
            background: #bdc3c7;
        }

        .move-item.current {
            background: #3498db;
            color: white;
        }

        .status-bar {
            background: #34495e;
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .error-message {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .success-message {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .debug-info {
            background: #f39c12;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none !important;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .new-game-section {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }

        .new-game-section h3 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .new-game-section p {
            color: #856404;
            margin-bottom: 15px;
            font-style: italic;
        }

        .game-loaded-indicator {
            display: none;
            background: #d4edda;
            border: 2px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .game-loaded-indicator.show {
            display: block;
        }

        .game-loaded-indicator h4 {
            color: #155724;
            margin-bottom: 5px;
        }

        .game-loaded-indicator p {
            color: #155724;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .chessboard {
                width: 320px;
                height: 320px;
            }
            
            .square {
                font-size: 24px;
            }

            .move-display-section {
                order: 2;
                border-left: none;
                border-right: none;
                border-top: 3px solid #3498db;
                border-bottom: 3px solid #3498db;
                min-width: auto;
            }

            .move-number {
                font-size: 2em;
            }

            .move-text {
                font-size: 1.8em;
            }

            .controls {
                gap: 10px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 14px;
            }

            .status-bar {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>♔ Chess Game Demonstrator ♛</h1>
            <p>Upload PGN files or input moves manually to replay famous chess games</p>
        </div>

        <div class="main-content">
            <div class="chess-section">
                <div class="chessboard" id="chessboard"></div>
                
                <div class="controls">
                    <button class="btn btn-secondary" onclick="resetToStart()">⏮ Start</button>
                    <button class="btn btn-primary" onclick="previousMove()">⏪ Previous</button>
                    <button class="btn btn-primary" onclick="nextMove()">Next ⏩</button>
                    <button class="btn btn-danger" onclick="newGame()">🆕 New Game</button>
                </div>
            </div>

            <div class="move-display-section">
                <div class="current-move-display">
                    <div class="move-number" id="displayMoveNumber">-</div>
                    <div class="move-text" id="displayMoveText">-</div>
                    <div class="move-description" id="displayMoveDescription">Load a game to begin</div>
                </div>

                <div class="position-info">
                    <h4>📊 Position Info</h4>
                    <div class="info-item">
                        <span class="info-label">Progress:</span>
                        <span class="info-value">
                            <span id="progressCurrent">0</span> / <span id="progressTotal">0</span>
                        </span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">To Move:</span>
                        <span class="info-value" id="toMoveDisplay">White</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Position:</span>
                        <span class="info-value" id="positionType">Starting</span>
                    </div>
                </div>

                <div class="game-info" id="gameInfo">
                    <h4>🏆 Game Information</h4>
                    <div class="info-row">
                        <span><strong>White:</strong></span>
                        <span id="whitePlayer">-</span>
                    </div>
                    <div class="info-row">
                        <span><strong>Black:</strong></span>
                        <span id="blackPlayer">-</span>
                    </div>
                    <div class="info-row">
                        <span><strong>Event:</strong></span>
                        <span id="eventName">-</span>
                    </div>
                    <div class="info-row">
                        <span><strong>Date:</strong></span>
                        <span id="gameDate">-</span>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="new-game-section" id="newGameSection">
                    <h3>🎯 Ready for a New Game?</h3>
                    <p>Click "New Game" to clear the current game and load fresh content</p>
                    <button class="btn btn-danger" onclick="newGame()">🆕 Start New Game</button>
                </div>

                <div class="game-loaded-indicator" id="gameLoadedIndicator">
                    <h4>✅ Game Loaded</h4>
                    <p>Use the navigation controls to explore the moves, or start a new game to load different content.</p>
                </div>

                <div class="debug-info" id="debugInfo">
                    Debug info will appear here when needed
                </div>

                <div class="input-section">
                    <h3>🎯 Famous Games</h3>
                    <select id="famousGamesSelect" onchange="loadFamousGame()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; margin-bottom: 15px; background: white;">
                        <option value="">Select a famous game...</option>
                        <option value="marshall_gold_coins">Marshall's Gold Coin Game (1912)</option>
                        <option value="fischer_game_century">Fischer's Game of the Century (1956)</option>
                        <option value="kildea_fletcher_morrow">James Kildea at the Fletcher Morrow Shield (2025)</option>
                    </select>
                    <div class="success-message" id="famousGameSuccess"></div>
                </div>

                <div class="input-section">
                    <h3>✏️ Manual Move Input</h3>
                    <textarea id="manualMoves" placeholder="Enter moves in algebraic notation:&#10;&#10;1.e4 e5 2.Nf3 Nc6 3.Bb5 a6 4.Ba4 Nf6 5.O-O Be7 6.Re1 b5 7.Bb3 d6 8.c3 O-O..."></textarea>
                    <button class="btn btn-success" onclick="loadManualMoves()">Load Moves</button>
                    <div class="error-message" id="manualError"></div>
                    <div class="success-message" id="manualSuccess"></div>
                </div>

                <div class="moves-display">
                    <h4>📝 Moves</h4>
                    <div class="move-list" id="movesList"></div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span>Move: <span id="currentMove">0</span> / <span id="totalMoves">0</span></span>
            <span id="statusMessage">Load a game to begin</span>
        </div>
    </div>

    <script>
        // Chess Game Manager
        class ChessGame {
            constructor() {
                this.reset();
                this.debugMode = false;
            }

            reset() {
                this.moves = [];
                this.algebraicMoves = [];
                this.currentMove = 0;
                this.gameInfo = {
                    white: '-',
                    black: '-',
                    event: '-',
                    date: '-',
                    result: '*'
                };
                this.boardHistory = [];
                this.parseErrors = [];
            }

            createInitialBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    ['.', '.', '.', '.', '.', '.', '.', '.'],
                    ['.', '.', '.', '.', '.', '.', '.', '.'],
                    ['.', '.', '.', '.', '.', '.', '.', '.'],
                    ['.', '.', '.', '.', '.', '.', '.', '.'],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            parseSquare(square) {
                if (!square || square.length !== 2) {
                    throw new Error(`Invalid square notation: ${square}`);
                }
                const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
                const rank = 8 - parseInt(square[1]);
                
                if (file < 0 || file > 7 || rank < 0 || rank > 7 || isNaN(rank)) {
                    throw new Error(`Invalid square coordinates: ${square}`);
                }
                
                return [rank, file];
            }

            squareToNotation(rank, file) {
                if (rank < 0 || rank > 7 || file < 0 || file > 7) {
                    throw new Error(`Invalid coordinates: rank=${rank}, file=${file}`);
                }
                return String.fromCharCode('a'.charCodeAt(0) + file) + (8 - rank);
            }

            cloneBoard(board) {
                return board.map(row => [...row]);
            }

            applyMoveToBoard(board, move) {
                try {
                    const [fromRank, fromFile] = this.parseSquare(move.from);
                    const [toRank, toFile] = this.parseSquare(move.to);
                    
                    if (fromRank < 0 || fromRank > 7 || fromFile < 0 || fromFile > 7 ||
                        toRank < 0 || toRank > 7 || toFile < 0 || toFile > 7) {
                        throw new Error(`Invalid move coordinates: ${move.from} to ${move.to}`);
                    }
                    
                    const piece = board[fromRank][fromFile];
                    if (piece === '.') {
                        this.debugLog(`Warning: Moving empty square from ${move.from}`);
                    }
                    
                    board[toRank][toFile] = piece;
                    board[fromRank][fromFile] = '.';
                    
                    // Handle castling
                    if (piece === 'K' || piece === 'k') {
                        const fileDiff = toFile - fromFile;
                        if (Math.abs(fileDiff) === 2) {
                            if (fileDiff === 2) {
                                if (board[toRank][7] === (piece === 'K' ? 'R' : 'r')) {
                                    board[toRank][5] = board[toRank][7];
                                    board[toRank][7] = '.';
                                }
                            } else if (fileDiff === -2) {
                                if (board[toRank][0] === (piece === 'K' ? 'R' : 'r')) {
                                    board[toRank][3] = board[toRank][0];
                                    board[toRank][0] = '.';
                                }
                            }
                        }
                    }
                    
                    return board;
                } catch (error) {
                    this.debugLog(`Error applying move ${move.from}-${move.to}: ${error.message}`);
                    throw error;
                }
            }

            getCurrentBoard() {
                try {
                    if (this.boardHistory[this.currentMove]) {
                        return this.cloneBoard(this.boardHistory[this.currentMove]);
                    }
                    
                    let board = this.createInitialBoard();
                    this.boardHistory[0] = this.cloneBoard(board);
                    
                    for (let i = 0; i < this.currentMove && i < this.moves.length; i++) {
                        try {
                            board = this.applyMoveToBoard(this.cloneBoard(board), this.moves[i]);
                            this.boardHistory[i + 1] = this.cloneBoard(board);
                        } catch (error) {
                            this.debugLog(`Error at move ${i + 1}: ${error.message}`);
                            return this.boardHistory[i] || this.createInitialBoard();
                        }
                    }
                    
                    return board;
                } catch (error) {
                    this.debugLog(`Error getting current board: ${error.message}`);
                    return this.createInitialBoard();
                }
            }

            debugLog(message) {
                if (this.debugMode) {
                    console.log(`ChessGame Debug: ${message}`);
                    const debugElement = document.getElementById('debugInfo');
                    if (debugElement) {
                        debugElement.innerHTML += `${message}<br>`;
                        debugElement.style.display = 'block';
                    }
                }
            }

            loadPGN(pgnText) {
                try {
                    this.reset();
                    this.debugMode = false;
                    
                    const headerRegex = /\[(\w+)\s+"([^"]+)"\]/g;
                    let match;
                    while ((match = headerRegex.exec(pgnText)) !== null) {
                        const [, key, value] = match;
                        switch (key.toLowerCase()) {
                            case 'white': this.gameInfo.white = value; break;
                            case 'black': this.gameInfo.black = value; break;
                            case 'event': this.gameInfo.event = value; break;
                            case 'date': this.gameInfo.date = value; break;
                            case 'result': this.gameInfo.result = value; break;
                        }
                    }
                    
                    let movesSection = pgnText.replace(/\[[^\]]*\]/g, '').trim();
                    movesSection = movesSection.replace(/\{[^}]*\}/g, '');
                    movesSection = movesSection.replace(/\([^)]*\)/g, '');
                    movesSection = movesSection.replace(/[0-9]+\./g, '');
                    movesSection = movesSection.replace(/1-0|0-1|1\/2-1\/2|\*/g, '');
                    movesSection = movesSection.replace(/[+#!?]+/g, '');
                    
                    const movesList = movesSection.split(/\s+/).filter(move => move.length > 0);
                    
                    this.debugLog(`Extracted ${movesList.length} moves from PGN`);
                    
                    const result = this.loadMovesList(movesList);
                    this.debugMode = false;
                    return result;
                } catch (error) {
                    this.debugLog(`PGN parsing error: ${error.message}`);
                    console.error('PGN parsing error:', error);
                    this.debugMode = false;
                    return false;
                }
            }

            loadManualMoves(movesText) {
                try {
                    this.reset();
                    this.debugMode = false;
                    
                    this.gameInfo = {
                        white: 'Player 1',
                        black: 'Player 2',
                        event: 'Manual Input',
                        date: new Date().toISOString().split('T')[0],
                        result: '*'
                    };
                    
                    let cleanMoves = movesText.replace(/\n/g, ' ');
                    cleanMoves = cleanMoves.replace(/[0-9]+\./g, '');
                    cleanMoves = cleanMoves.replace(/\s+/g, ' ').trim();
                    cleanMoves = cleanMoves.replace(/[+#!?]+/g, '');
                    
                    const movesList = cleanMoves.split(' ').filter(move => move.length > 0);
                    
                    this.debugLog(`Processing ${movesList.length} manual moves`);
                    
                    const result = this.loadMovesList(movesList);
                    this.debugMode = false;
                    return result;
                } catch (error) {
                    this.debugLog(`Manual moves parsing error: ${error.message}`);
                    console.error('Manual moves parsing error:', error);
                    this.debugMode = false;
                    return false;
                }
            }

            loadMovesList(movesList) {
                this.moves = [];
                this.algebraicMoves = [];
                this.boardHistory = [];
                this.parseErrors = [];
                
                let board = this.createInitialBoard();
                this.boardHistory[0] = this.cloneBoard(board);
                
                for (let i = 0; i < movesList.length; i++) {
                    try {
                        const moveStr = movesList[i];
                        this.debugLog(`Processing move ${i + 1}: ${moveStr}`);
                        
                        const cleanMove = moveStr.replace(/[+#!?]$/g, '');
                        const move = this.parseMove(cleanMove, board, this.moves.length);
                        
                        if (move) {
                            try {
                                const testBoard = this.cloneBoard(board);
                                this.applyMoveToBoard(testBoard, move);
                                
                                this.moves.push(move);
                                this.algebraicMoves.push(moveStr);
                                board = this.applyMoveToBoard(this.cloneBoard(board), move);
                                this.boardHistory[i + 1] = this.cloneBoard(board);
                                
                                this.debugLog(`Successfully processed move ${i + 1}: ${moveStr} (${move.from}-${move.to})`);
                            } catch (applyError) {
                                this.debugLog(`Failed to apply move ${i + 1}: ${moveStr} - ${applyError.message}`);
                                this.parseErrors.push(`Move ${i + 1}: ${moveStr} - ${applyError.message}`);
                                continue;
                            }
                        } else {
                            this.debugLog(`Failed to parse move ${i + 1}: ${moveStr}`);
                            this.parseErrors.push(`Move ${i + 1}: ${moveStr} - Could not parse`);
                            continue;
                        }
                    } catch (error) {
                        this.debugLog(`Error processing move ${i + 1}: ${movesList[i]} - ${error.message}`);
                        this.parseErrors.push(`Move ${i + 1}: ${movesList[i]} - ${error.message}`);
                        continue;
                    }
                }
                
                this.debugLog(`Successfully loaded ${this.moves.length} moves out of ${movesList.length} attempted`);
                
                if (this.parseErrors.length > 0) {
                    this.debugLog(`Parse errors encountered: ${this.parseErrors.length}`);
                    console.warn('Parse errors:', this.parseErrors);
                }
                
                return this.moves.length > 0;
            }

            parseMove(moveStr, board, moveNumber) {
                try {
                    const isWhite = moveNumber % 2 === 0;
                    
                    // Handle castling
                    if (moveStr === 'O-O' || moveStr === '0-0') {
                        const rank = isWhite ? 7 : 0;
                        return { from: this.squareToNotation(rank, 4), to: this.squareToNotation(rank, 6), type: 'castle' };
                    }
                    if (moveStr === 'O-O-O' || moveStr === '0-0-0') {
                        const rank = isWhite ? 7 : 0;
                        return { from: this.squareToNotation(rank, 4), to: this.squareToNotation(rank, 2), type: 'castle' };
                    }
                    
                    // Simple pawn move
                    if (moveStr.match(/^[a-h][1-8]$/)) {
                        return this.findPawnMove(moveStr, board, isWhite);
                    }
                    
                    // Pawn capture
                    if (moveStr.match(/^[a-h]x[a-h][1-8]$/)) {
                        const fromFileChar = moveStr.charAt(0);
                        const fromFile = fromFileChar.charCodeAt(0) - 'a'.charCodeAt(0);
                        const toSquare = moveStr.substring(2);
                        
                        this.debugLog(`Parsing pawn capture: ${fromFileChar} file (${fromFile}) captures on ${toSquare}`);
                        return this.findPawnCapture(fromFile, toSquare, board, isWhite);
                    }
                    
                    // Piece moves
                    if (moveStr.match(/^[NBRQK]/)) {
                        const piece = moveStr[0];
                        const isCapture = moveStr.includes('x');
                        
                        let disambiguator = '';
                        let toSquare = '';
                        
                        if (isCapture) {
                            const parts = moveStr.split('x');
                            disambiguator = parts[0].substring(1);
                            toSquare = parts[1];
                        } else {
                            disambiguator = moveStr.substring(1, moveStr.length - 2);
                            toSquare = moveStr.substring(moveStr.length - 2);
                        }
                        
                        return this.findPieceMove(piece, toSquare, disambiguator, board, isWhite);
                    }
                    
                    this.debugLog(`Could not parse move format: ${moveStr}`);
                    return null;
                } catch (error) {
                    this.debugLog(`Error parsing move ${moveStr}: ${error.message}`);
                    return null;
                }
            }

            findPawnMove(toSquare, board, isWhite) {
                try {
                    const [toRank, toFile] = this.parseSquare(toSquare);
                    const pawn = isWhite ? 'P' : 'p';
                    
                    // Check one square back
                    const oneBack = isWhite ? toRank + 1 : toRank - 1;
                    if (oneBack >= 0 && oneBack < 8 && board[oneBack][toFile] === pawn) {
                        return { from: this.squareToNotation(oneBack, toFile), to: toSquare, type: 'pawn' };
                    }
                    
                    // Check two squares back for initial pawn move
                    const twoBack = isWhite ? toRank + 2 : toRank - 2;
                    if (twoBack >= 0 && twoBack < 8 && board[twoBack][toFile] === pawn && 
                        board[oneBack][toFile] === '.') {
                        return { from: this.squareToNotation(twoBack, toFile), to: toSquare, type: 'pawn' };
                    }
                    
                    return null;
                } catch (error) {
                    this.debugLog(`Error in findPawnMove: ${error.message}`);
                    return null;
                }
            }

            findPawnCapture(fromFile, toSquare, board, isWhite) {
                try {
                    const [toRank, toFile] = this.parseSquare(toSquare);
                    const pawn = isWhite ? 'P' : 'p';
                    const fromRank = isWhite ? toRank + 1 : toRank - 1;
                    
                    if (fromRank >= 0 && fromRank < 8 && fromFile >= 0 && fromFile < 8 &&
                        board[fromRank][fromFile] === pawn) {
                        
                        const targetPiece = board[toRank][toFile];
                        const isEnemyPiece = targetPiece !== '.' && 
                                           ((isWhite && targetPiece !== targetPiece.toUpperCase()) ||
                                            (!isWhite && targetPiece !== targetPiece.toLowerCase()));
                        
                        const isEnPassant = targetPiece === '.' && Math.abs(fromFile - toFile) === 1;
                        
                        if (isEnemyPiece || isEnPassant) {
                            return { 
                                from: this.squareToNotation(fromRank, fromFile), 
                                to: toSquare, 
                                type: 'pawn_capture'
                            };
                        }
                    }
                    
                    this.debugLog(`Pawn capture ${String.fromCharCode(97 + fromFile)}x${toSquare} not found`);
                    return null;
                } catch (error) {
                    this.debugLog(`Error in findPawnCapture: ${error.message}`);
                    return null;
                }
            }

            findPieceMove(piece, toSquare, disambiguator, board, isWhite) {
                try {
                    const searchPiece = isWhite ? piece : piece.toLowerCase();
                    const [toRank, toFile] = this.parseSquare(toSquare);
                    
                    const candidates = [];
                    for (let rank = 0; rank < 8; rank++) {
                        for (let file = 0; file < 8; file++) {
                            if (board[rank][file] === searchPiece) {
                                candidates.push({ rank, file });
                            }
                        }
                    }
                    
                    if (candidates.length === 0) {
                        this.debugLog(`No ${piece} found on board`);
                        return null;
                    }
                    
                    let validCandidates = candidates;
                    
                    if (disambiguator) {
                        if (disambiguator.match(/^[a-h]$/)) {
                            const file = disambiguator.charCodeAt(0) - 'a'.charCodeAt(0);
                            validCandidates = candidates.filter(c => c.file === file);
                        } else if (disambiguator.match(/^[1-8]$/)) {
                            const rank = 8 - parseInt(disambiguator);
                            validCandidates = candidates.filter(c => c.rank === rank);
                        } else if (disambiguator.match(/^[a-h][1-8]$/)) {
                            const [dRank, dFile] = this.parseSquare(disambiguator);
                            validCandidates = candidates.filter(c => c.rank === dRank && c.file === dFile);
                        }
                    }
                    
                    for (const candidate of validCandidates) {
                        if (this.canPieceMoveTo(piece.toLowerCase(), candidate.rank, candidate.file, toRank, toFile, board)) {
                            const from = this.squareToNotation(candidate.rank, candidate.file);
                            return { from, to: toSquare, type: 'piece' };
                        }
                    }
                    
                    if (validCandidates.length > 0) {
                        this.debugLog(`No legal move found, using first candidate for ${piece} to ${toSquare}`);
                        const from = this.squareToNotation(validCandidates[0].rank, validCandidates[0].file);
                        return { from, to: toSquare, type: 'piece' };
                    }
                    
                    this.debugLog(`No valid candidates found for ${piece} to ${toSquare}`);
                    return null;
                } catch (error) {
                    this.debugLog(`Error in findPieceMove: ${error.message}`);
                    return null;
                }
            }

            canPieceMoveTo(piece, fromRank, fromFile, toRank, toFile, board) {
                try {
                    switch (piece) {
                        case 'n':
                            return this.isValidKnightMove(fromRank, fromFile, toRank, toFile);
                        case 'r':
                            return this.isValidRookMove(fromRank, fromFile, toRank, toFile, board);
                        case 'b':
                            return this.isValidBishopMove(fromRank, fromFile, toRank, toFile, board);
                        case 'q':
                            return this.isValidQueenMove(fromRank, fromFile, toRank, toFile, board);
                        case 'k':
                            return this.isValidKingMove(fromRank, fromFile, toRank, toFile);
                        default:
                            return false;
                    }
                } catch (error) {
                    this.debugLog(`Error checking piece move validity: ${error.message}`);
                    return false;
                }
            }

            isValidKnightMove(fromRank, fromFile, toRank, toFile) {
                const rankDiff = Math.abs(toRank - fromRank);
                const fileDiff = Math.abs(toFile - fromFile);
                return (rankDiff === 2 && fileDiff === 1) || (rankDiff === 1 && fileDiff === 2);
            }

            isValidRookMove(fromRank, fromFile, toRank, toFile, board) {
                if (fromRank !== toRank && fromFile !== toFile) return false;
                return this.isPathClear(fromRank, fromFile, toRank, toFile, board);
            }

            isValidBishopMove(fromRank, fromFile, toRank, toFile, board) {
                if (Math.abs(fromRank - toRank) !== Math.abs(fromFile - toFile)) return false;
                return this.isPathClear(fromRank, fromFile, toRank, toFile, board);
            }

            isValidQueenMove(fromRank, fromFile, toRank, toFile, board) {
                return this.isValidRookMove(fromRank, fromFile, toRank, toFile, board) ||
                       this.isValidBishopMove(fromRank, fromFile, toRank, toFile, board);
            }

            isValidKingMove(fromRank, fromFile, toRank, toFile) {
                return Math.abs(fromRank - toRank) <= 1 && Math.abs(fromFile - toFile) <= 1;
            }

            isPathClear(fromRank, fromFile, toRank, toFile, board) {
                try {
                    const rankStep = toRank > fromRank ? 1 : (toRank < fromRank ? -1 : 0);
                    const fileStep = toFile > fromFile ? 1 : (toFile < fromFile ? -1 : 0);
                    
                    let currentRank = fromRank + rankStep;
                    let currentFile = fromFile + fileStep;
                    
                    while (currentRank !== toRank || currentFile !== toFile) {
                        if (currentRank < 0 || currentRank > 7 || currentFile < 0 || currentFile > 7) {
                            return false;
                        }
                        if (board[currentRank][currentFile] !== '.') {
                            return false;
                        }
                        currentRank += rankStep;
                        currentFile += fileStep;
                    }
                    
                    return true;
                } catch (error) {
                    this.debugLog(`Error checking path: ${error.message}`);
                    return false;
                }
            }

            nextMove() {
                if (this.currentMove < this.moves.length) {
                    this.currentMove++;
                    return true;
                }
                return false;
            }

            previousMove() {
                if (this.currentMove > 0) {
                    this.currentMove--;
                    return true;
                }
                return false;
            }

            goToMove(moveNumber) {
                if (moveNumber >= 0 && moveNumber <= this.moves.length) {
                    this.currentMove = moveNumber;
                    return true;
                }
                return false;
            }

            hasGameLoaded() {
                return this.moves.length > 0;
            }

            getPosition() {
                try {
                    const board = this.getCurrentBoard();
                    return {
                        board: board,
                        move_number: this.currentMove,
                        total_moves: this.moves.length,
                        algebraic_moves: this.algebraicMoves,
                        game_info: this.gameInfo,
                        last_move: this.currentMove > 0 ? this.moves[this.currentMove - 1] : null,
                        parse_errors: this.parseErrors
                    };
                } catch (error) {
                    console.error('Error getting position:', error);
                    return {
                        board: this.createInitialBoard(),
                        move_number: 0,
                        total_moves: 0,
                        algebraic_moves: [],
                        game_info: this.gameInfo,
                        last_move: null,
                        parse_errors: this.parseErrors
                    };
                }
            }
        }

        // Global game instance
        const chessGame = new ChessGame();

        // Unicode chess pieces
        const pieces = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        let currentHighlight = null;

        function initChessboard() {
            const board = document.getElementById('chessboard');
            board.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.id = `${String.fromCharCode(97 + col)}${8 - row}`;
                    board.appendChild(square);
                }
            }
        }

        function updateBoard(boardArray) {
            try {
                document.querySelectorAll('.square').forEach(square => {
                    square.textContent = '';
                    square.classList.remove('highlight');
                });
                
                if (!boardArray || boardArray.length !== 8) {
                    console.error('Invalid board array');
                    return;
                }
                
                for (let row = 0; row < 8; row++) {
                    if (!boardArray[row] || boardArray[row].length !== 8) {
                        console.error(`Invalid board row ${row}`);
                        continue;
                    }
                    
                    for (let col = 0; col < 8; col++) {
                        const piece = boardArray[row][col];
                        if (piece !== '.') {
                            const squareId = String.fromCharCode(97 + col) + (8 - row);
                            const square = document.getElementById(squareId);
                            if (square) {
                                const pieceSymbol = pieces[piece];
                                if (pieceSymbol) {
                                    square.textContent = pieceSymbol;
                                } else {
                                    console.warn(`Unknown piece: ${piece} at ${squareId}`);
                                }
                            } else {
                                console.error(`Square not found: ${squareId}`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating board:', error);
            }
        }

        function highlightLastMove(lastMove) {
            try {
                if (currentHighlight) {
                    currentHighlight.forEach(square => {
                        if (square) {
                            square.classList.remove('highlight');
                        }
                    });
                    currentHighlight = null;
                }
                
                if (lastMove && lastMove.from && lastMove.to) {
                    const fromSquare = document.getElementById(lastMove.from);
                    const toSquare = document.getElementById(lastMove.to);
                    
                    if (fromSquare && toSquare) {
                        fromSquare.classList.add('highlight');
                        toSquare.classList.add('highlight');
                        currentHighlight = [fromSquare, toSquare];
                    }
                }
            } catch (error) {
                console.error('Error highlighting move:', error);
            }
        }

        function updateGameInfo(gameInfo) {
            try {
                document.getElementById('whitePlayer').textContent = gameInfo.white || '-';
                document.getElementById('blackPlayer').textContent = gameInfo.black || '-';
                document.getElementById('eventName').textContent = gameInfo.event || '-';
                document.getElementById('gameDate').textContent = gameInfo.date || '-';
            } catch (error) {
                console.error('Error updating game info:', error);
            }
        }

        function updateMovesList(moves, currentMove) {
            try {
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                
                moves.forEach((move, index) => {
                    const moveElement = document.createElement('span');
                    moveElement.className = `move-item ${index < currentMove ? 'played' : ''} ${index === currentMove - 1 ? 'current' : ''}`;
                    moveElement.textContent = `${Math.floor(index / 2) + 1}${index % 2 === 0 ? '.' : '...'} ${move}`;
                    moveElement.onclick = () => goToMove(index + 1);
                    movesList.appendChild(moveElement);
                });
            } catch (error) {
                console.error('Error updating moves list:', error);
            }
        }

        function updateMoveDisplay(positionData) {
            try {
                const moveNumber = positionData.move_number;
                const totalMoves = positionData.total_moves;
                const algebraicMoves = positionData.algebraic_moves;
                
                document.getElementById('progressCurrent').textContent = moveNumber;
                document.getElementById('progressTotal').textContent = totalMoves;
                
                if (moveNumber === 0) {
                    document.getElementById('displayMoveNumber').textContent = '-';
                    document.getElementById('displayMoveText').textContent = 'Start';
                    document.getElementById('displayMoveDescription').textContent = 'Starting position';
                    document.getElementById('toMoveDisplay').textContent = 'White';
                    document.getElementById('positionType').textContent = 'Opening';
                } else if (moveNumber <= algebraicMoves.length) {
                    const fullMoveNumber = Math.ceil(moveNumber / 2);
                    const isWhiteMove = (moveNumber - 1) % 2 === 0;
                    const currentMove = algebraicMoves[moveNumber - 1];
                    
                    const moveNumberDisplay = isWhiteMove ? 
                        `${fullMoveNumber}.` : 
                        `${fullMoveNumber}...`;
                    
                    document.getElementById('displayMoveNumber').textContent = moveNumberDisplay;
                    document.getElementById('displayMoveText').textContent = currentMove || 'Error';
                    
                    const playerColor = isWhiteMove ? 'White' : 'Black';
                    const nextToMove = isWhiteMove ? 'Black' : 'White';
                    document.getElementById('displayMoveDescription').textContent = 
                        `${playerColor} played ${currentMove || 'Error'}`;
                    
                    document.getElementById('toMoveDisplay').textContent = nextToMove;
                    
                    let positionType;
                    if (moveNumber <= 10) {
                        positionType = 'Opening';
                    } else if (moveNumber <= totalMoves * 0.7) {
                        positionType = 'Middlegame';
                    } else {
                        positionType = 'Endgame';
                    }
                    document.getElementById('positionType').textContent = positionType;
                } else {
                    document.getElementById('displayMoveNumber').textContent = 'Error';
                    document.getElementById('displayMoveText').textContent = 'Error';
                    document.getElementById('displayMoveDescription').textContent = 'Invalid move number';
                    document.getElementById('toMoveDisplay').textContent = '-';
                    document.getElementById('positionType').textContent = 'Error';
                }
            } catch (error) {
                console.error('Error updating move display:', error);
            }
        }

        function updateGameLoadedIndicator() {
            try {
                const indicator = document.getElementById('gameLoadedIndicator');
                const newGameSection = document.getElementById('newGameSection');
                
                if (chessGame.hasGameLoaded()) {
                    indicator.classList.add('show');
                    newGameSection.style.display = 'none';
                } else {
                    indicator.classList.remove('show');
                    newGameSection.style.display = 'block';
                }
            } catch (error) {
                console.error('Error updating game loaded indicator:', error);
            }
        }

        function updatePosition() {
            try {
                const positionData = chessGame.getPosition();
                
                updateBoard(positionData.board);
                highlightLastMove(positionData.last_move);
                updateGameInfo(positionData.game_info);
                updateMovesList(positionData.algebraic_moves, positionData.move_number);
                updateMoveDisplay(positionData);
                updateGameLoadedIndicator();
                
                document.getElementById('currentMove').textContent = positionData.move_number;
                document.getElementById('totalMoves').textContent = positionData.total_moves;
                
                if (positionData.total_moves === 0) {
                    document.getElementById('statusMessage').textContent = 'Load a game to begin';
                } else if (positionData.move_number === 0) {
                    document.getElementById('statusMessage').textContent = 'Starting position';
                } else if (positionData.move_number <= positionData.algebraic_moves.length) {
                    document.getElementById('statusMessage').textContent = 
                        `After ${positionData.algebraic_moves[positionData.move_number - 1]}`;
                } else {
                    document.getElementById('statusMessage').textContent = 'End of game';
                }
                
                if (positionData.parse_errors && positionData.parse_errors.length > 0) {
                    console.warn('Parse errors detected:', positionData.parse_errors);
                }
            } catch (error) {
                console.error('Error updating position:', error);
                document.getElementById('statusMessage').textContent = 'Error updating position';
            }
        }

        function showMessage(elementId, message, isError = false) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = message;
                    element.style.display = 'block';
                    setTimeout(() => {
                        element.style.display = 'none';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error showing message:', error);
            }
        }

        function clearInputs() {
            try {
                document.getElementById('manualMoves').value = '';
                document.getElementById('famousGamesSelect').selectedIndex = 0;
                
                const debugElement = document.getElementById('debugInfo');
                if (debugElement) {
                    debugElement.style.display = 'none';
                    debugElement.innerHTML = '';
                }
            } catch (error) {
                console.error('Error clearing inputs:', error);
            }
        }

        // Famous games database
        const FAMOUS_GAMES = {
            marshall_gold_coins: {
                name: "Marshall's Gold Coin Game",
                description: "Levitsky vs Marshall, 1912 - The spectacular queen sacrifice",
                pgn: `[Event "18th DSB Kongress"]
[Site "Breslau GER"]
[Date "1912.07.20"]
[EventDate "1912.07.15"]
[Round "6"]
[Result "0-1"]
[White "Stefan Levitsky"]
[Black "Frank James Marshall"]
[ECO "C10"]

1.d4 e6 2.e4 d5 3.Nc3 c5 4.Nf3 Nc6 5.exd5 exd5 6.Be2 Nf6 7.O-O Be7 8.Bg5 O-O 9.dxc5 Be6 10.Nd4 Bxc5 11.Nxe6 fxe6 12.Bg4 Qd6 13.Bh3 Rae8 14.Qd2 Bb4 15.Bxf6 Rxf6 16.Rad1 Qc5 17.Qe2 Bxc3 18.bxc3 Qxc3 19.Rxd5 Nd4 20.Qh5 Ref8 21.Re5 Rh6 22.Qg5 Rxh3 23.Rc5 Qg3 0-1`
            },
            fischer_game_century: {
                name: "Fischer's Game of the Century",
                description: "Donald Byrne vs 13-year-old Bobby Fischer, 1956 - A masterpiece",
                pgn: `[Event "Third Rosenwald Trophy"]
[Site "New York, NY USA"]
[Date "1956.10.17"]
[Round "8"]
[Result "0-1"]
[White "Donald Byrne"]
[Black "Robert James Fischer"]
[ECO "D92"]

1. Nf3 Nf6 2. c4 g6 3. Nc3 Bg7 4. d4 O-O 5. Bf4 d5 6. Qb3 dxc4 7. Qxc4 c6 8. e4 Nbd7 9. Rd1 Nb6 10. Qc5 Bg4 11. Bg5 Na4 12. Qa3 Nxc3 13. bxc3 Nxe4 14. Bxe7 Qb6 15. Bc4 Nxc3 16. Bc5 Rfe8+ 17. Kf1 Be6 18. Bxb6 Bxc4+ 19. Kg1 Ne2+ 20. Kf1 Nxd4+ 21. Kg1 Ne2+ 22. Kf1 Nc3+ 23. Kg1 axb6 24. Qb4 Ra4 25. Qxb6 Nxd1 26. h3 Rxa2 27. Kh2 Nxf2 28. Re1 Rxe1 29. Qd8+ Bf8 30. Nxe1 Bd5 31. Nf3 Ne4 32. Qb8 b5 33. h4 h5 34. Ne5 Kg7 35. Kg1 Bc5+ 36. Kf1 Ng3+ 37. Ke1 Bb4+ 38. Kd1 Bb3+ 39. Kc1 Ne2+ 40. Kb1 Nc3+ 41. Kc1 Rc2# 0-1`
            },
            kildea_fletcher_morrow: {
                name: "James Kildea at the Fletcher Morrow Shield (2025)",
                description: "James Kildea vs Jason Barnett, 2025 - A modern tactical victory",
                pgn: `[Event "Fletcher Morrow Shield"]
[Site "Ballarat Mechanics Institute"]
[Date "2025.8.10"]
[Round "1"]
[White "James Kildea (Me)"]
[Black "Jason Barnett"]
[Result "1-0"]

1. e4 c6 2. d4 d5 3. Nc3 dxe4 4. Nxe4 Bf5 5. Ng3 Bg6 6. Nf3 e6 7. Ne5 Nf6 8. Nxg6 hxg6 9. Be3 Nd5 10. Qd2 Nxe3 11. Qxe3 Bb4+ 12. c3 Ba5 13. Be2 Nd7 14. Ne4 Qe7 15. O-O Bc7 16. h3 Qh4 17. c4 Qf4 18. Qxf4 Bxf4 19. Rfd1 f5 20. Nc3 Nf6 21. d5 cxd5 22. cxd5 exd5 23. Nxd5 Nxd5 24. Rxd5 Ke7 25. Re1 Kf6 26. g3 Be5 27. Rd7 Rxh3 28. Bc4 Bxb2 29. f4 Bd4+ 30. Kg2 1-0`
            }
        };

        function loadFamousGame() {
            try {
                const selectedGame = document.getElementById('famousGamesSelect').value;
                
                if (!selectedGame || !FAMOUS_GAMES[selectedGame]) {
                    return;
                }
                
                const game = FAMOUS_GAMES[selectedGame];
                
                if (chessGame.loadPGN(game.pgn)) {
                    updatePosition();
                    showMessage('famousGameSuccess', `${game.name} loaded successfully!`);
                    document.getElementById('statusMessage').textContent = `${game.name} - ${game.description}`;
                    
                    document.getElementById('manualMoves').value = '';
                } else {
                    showMessage('famousGameSuccess', 'Error loading the selected game', true);
                }
            } catch (error) {
                console.error('Error loading famous game:', error);
                showMessage('famousGameSuccess', 'Error loading the selected game', true);
            }
        }

        function newGame() {
            try {
                if (chessGame.hasGameLoaded()) {
                    if (!confirm('Are you sure you want to start a new game? This will clear the current game.')) {
                        return;
                    }
                }
                
                chessGame.reset();
                clearInputs();
                
                document.querySelectorAll('.error-message, .success-message, .debug-info').forEach(msg => {
                    msg.style.display = 'none';
                });
                
                updatePosition();
                document.getElementById('statusMessage').textContent = 'Ready for new game - load famous games or enter moves';
            } catch (error) {
                console.error('Error starting new game:', error);
            }
        }

        function loadManualMoves() {
            try {
                const moves = document.getElementById('manualMoves').value;
                if (!moves.trim()) {
                    showMessage('manualError', 'Please enter moves', true);
                    return;
                }

                if (chessGame.loadManualMoves(moves)) {
                    updatePosition();
                    showMessage('manualSuccess', 'Moves loaded successfully!');
                    document.getElementById('statusMessage').textContent = 'Moves loaded successfully!';
                } else {
                    showMessage('manualError', 'Error: Invalid move format or no valid moves found', true);
                }
            } catch (error) {
                console.error('Error loading manual moves:', error);
                showMessage('manualError', 'Error: Failed to load moves', true);
            }
        }

        function nextMove() {
            try {
                if (chessGame.nextMove()) {
                    updatePosition();
                }
            } catch (error) {
                console.error('Error going to next move:', error);
                document.getElementById('statusMessage').textContent = 'Error navigating to next move';
            }
        }

        function previousMove() {
            try {
                if (chessGame.previousMove()) {
                    updatePosition();
                }
            } catch (error) {
                console.error('Error going to previous move:', error);
                document.getElementById('statusMessage').textContent = 'Error navigating to previous move';
            }
        }

        function resetToStart() {
            try {
                chessGame.currentMove = 0;
                updatePosition();
            } catch (error) {
                console.error('Error resetting to start:', error);
                document.getElementById('statusMessage').textContent = 'Error resetting to start';
            }
        }

        function goToMove(moveNumber) {
            try {
                if (chessGame.goToMove(moveNumber)) {
                    updatePosition();
                }
            } catch (error) {
                console.error('Error going to move:', error);
                document.getElementById('statusMessage').textContent = 'Error navigating to move';
            }
        }

        // Keyboard shortcuts with error handling
        document.addEventListener('keydown', function(e) {
            try {
                if (e.target.tagName === 'TEXTAREA') return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        previousMove();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        nextMove();
                        break;
                    case 'Home':
                        e.preventDefault();
                        resetToStart();
                        break;
                    case 'n':
                    case 'N':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            newGame();
                        }
                        break;
                }
            } catch (error) {
                console.error('Error handling keyboard shortcut:', error);
            }
        });

        // Initialize the board when page loads
        document.addEventListener('DOMContentLoaded', function() {
            try {
                initChessboard();
                updatePosition();
            } catch (error) {
                console.error('Error during initialization:', error);
                document.getElementById('statusMessage').textContent = 'Error during initialization';
            }
        });

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            document.getElementById('statusMessage').textContent = 'An error occurred - please refresh the page';
        });

        // Unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
            document.getElementById('statusMessage').textContent = 'An error occurred - please refresh the page';
        });
    </script>
</body>
</html>
                    